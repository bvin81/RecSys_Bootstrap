import random
import json
import requests
import time
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from concurrent.futures import ThreadPoolExecutor
import logging

# Logging be√°ll√≠t√°sa
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class VirtualUser:
    """
    Virtu√°lis felhaszn√°l√≥ A/B/C csoportonk√©nti l√°that√≥s√°ggal
    JAV√çTOTT VERZI√ì - csoportonk√©nti d√∂nt√©si logik√°val
    """
    
    def __init__(self, user_type, username, group='A'):
        self.user_type = user_type
        self.username = username
        self.group = group
        self.session = requests.Session()
        self.base_url = "https://boots-c9ce40a0998d.herokuapp.com"
        
        # Preferencia s√∫lyok (0-1 sk√°la)
        self.preferences = self._get_preferences(user_type)
        
        # V√°laszt√°si statisztik√°k
        self.choices_made = []
        self.session_start_time = None
        self.total_choices = 0
        
    def _get_preferences(self, user_type):
        """Felhaszn√°l√≥ t√≠pus alapj√°n preferencia s√∫lyok"""
        preferences = {
            'egeszsegtudatos': {
                'hsi_weight': 0.8,
                'esi_weight': 0.1, 
                'ppi_weight': 0.1,
                'choice_probability': 0.85,
                'choices_per_session': (4, 8),
                'description': 'Magas HSI √©rt√©keket keres'
            },
            'kornyezettudatos': {
                'hsi_weight': 0.2,
                'esi_weight': 0.7,
                'ppi_weight': 0.1,
                'choice_probability': 0.80,
                'choices_per_session': (3, 7),
                'description': 'Alacsony k√∂rnyezeti hat√°st keres'
            },
            'izorgia': {
                'hsi_weight': 0.1,
                'esi_weight': 0.1,
                'ppi_weight': 0.8,
                'choice_probability': 0.90,
                'choices_per_session': (5, 10),
                'description': 'Magas PPI √©rt√©keket keres'
            },
            'kiegyensulyozott': {
                'hsi_weight': 0.33,
                'esi_weight': 0.33,
                'ppi_weight': 0.34,
                'choice_probability': 0.75,
                'choices_per_session': (3, 6),
                'description': 'Minden szempontot egyform√°n fontosnak tart'
            },
            'kenyelmi': {
                'hsi_weight': 0.2,
                'esi_weight': 0.1,
                'ppi_weight': 0.7,
                'choice_probability': 0.95,
                'choices_per_session': (2, 5),
                'description': 'N√©pszer≈±, k√∂nny≈± recepteket keres'
            },
            'ujdonsagkereso': {
                'hsi_weight': 0.3,
                'esi_weight': 0.3,
                'ppi_weight': 0.4,
                'novelty_bonus': 0.5,
                'choice_probability': 0.70,
                'choices_per_session': (4, 9),
                'description': 'Ritka recepteket prefer√°l'
            }
        }
        return preferences.get(user_type, preferences['kiegyensulyozott'])
    
    def register(self):
        """Regisztr√°ci√≥ a rendszerbe"""
        try:
            # GET a regisztr√°ci√≥s oldalhoz
            response = self.session.get(f"{self.base_url}/register", timeout=10)
            
            # POST regisztr√°ci√≥
            register_data = {
                'username': self.username,
                'password': 'test123',
                'confirm_password': 'test123'
            }
            
            response = self.session.post(f"{self.base_url}/register", data=register_data, timeout=10)
            
            if response.status_code == 200 and 'Sikeres regisztr√°ci√≥' in response.text:
                logger.info(f"‚úÖ {self.username} regisztr√°lva")
                return True
            else:
                logger.warning(f"‚ùå {self.username} regisztr√°ci√≥ sikertelen")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Regisztr√°ci√≥ hiba {self.username}: {e}")
            return False
    
    def login(self):
        """Bejelentkez√©s"""
        try:
            login_data = {
                'username': self.username,
                'password': 'test123'
            }
            
            response = self.session.post(f"{self.base_url}/login", data=login_data, timeout=10)
            
            if response.status_code == 200 and ('√údv√∂z√∂llek' in response.text or '√ºdv√∂z√∂llek' in response.text):
                logger.info(f"‚úÖ {self.username} bejelentkezve")
                
                # Csoport kinyer√©se a HTML-b≈ël
                if 'A csoport' in response.text or 'group-indicator">Tesztcsoport: A' in response.text:
                    self.group = 'A'
                elif 'B csoport' in response.text or 'group-indicator">Tesztcsoport: B' in response.text:
                    self.group = 'B'
                elif 'C csoport' in response.text or 'group-indicator">Tesztcsoport: C' in response.text:
                    self.group = 'C'
                
                logger.info(f"üéØ {self.username} besorolva: {self.group} csoport")
                return True
            else:
                logger.warning(f"‚ùå {self.username} bejelentkez√©s sikertelen")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Bejelentkez√©s hiba {self.username}: {e}")
            return False
    
    def get_recommendations(self):
        """Val√≥s k√∂r√∂nk√©nti aj√°nl√°sok lek√©r√©se"""
        try:
            # Val√≥s API h√≠v√°s - NEM mock!
            response = self.session.post(
                f"{self.base_url}/recommend", 
                headers={'Content-Type': 'application/json'},
                json={},  # √úres JSON body
                timeout=15
            )
            
            if response.status_code == 200:
                try:
                    # Pr√≥b√°ljuk meg JSON-k√©nt parsolni
                    recommendations = response.json().get('recommendations', [])
                    
                    if recommendations:
                        logger.info(f"üéØ {self.username} kapott {len(recommendations)} VAL√ìS aj√°nl√°st")
                        
                        # Ellen≈ërizz√ºk van-e round_number √©s recommendation_type
                        if recommendations and 'round_number' in recommendations[0]:
                            round_num = recommendations[0]['round_number']
                            rec_types = [rec.get('recommendation_type', 'unknown') for rec in recommendations]
                            logger.info(f"üìä {self.username} - {round_num}. k√∂r, t√≠pusok: {set(rec_types)}")
                        
                        return recommendations
                    else:
                        logger.warning(f"‚ö†Ô∏è {self.username} - √úres aj√°nl√°sok a v√°laszban")
                        return self._generate_mock_recommendations()
                        
                except ValueError:
                    # Nem JSON v√°lasz - val√≥sz√≠n≈±leg HTML
                    logger.warning(f"‚ö†Ô∏è {self.username} - HTML v√°lasz, mock haszn√°lata")
                    return self._generate_mock_recommendations()
            else:
                logger.warning(f"‚ùå {self.username} - HTTP {response.status_code}")
                return self._generate_mock_recommendations()
                
        except Exception as e:
            logger.error(f"‚ùå {self.username} aj√°nl√°s hiba: {e}")
            return self._generate_mock_recommendations()
    
    def _generate_mock_recommendations(self):
        """Mock aj√°nl√°sok gener√°l√°sa fallback-k√©nt"""
        recommendations = []
        for i in range(5):  # 5 aj√°nl√°s
            recipe = {
                'id': random.randint(1, 1000),
                'title': f"Virtu√°lis Recept {i+1}",
                'hsi': random.randint(30, 95),
                'esi': random.randint(20, 200),
                'ppi': random.randint(40, 90),
                'category': random.choice(['F≈ë√©tel', 'Sal√°ta', 'Leves', 'Desszert']),
                'ingredients': f"Mock √∂sszetev≈ëk {i+1}",
                'composite_score': 0,
                'round_number': len(self.choices_made) + 1,
                'recommendation_type': 'mock'
            }
            
            # Kompozit pontsz√°m sz√°m√≠t√°sa
            recipe['composite_score'] = (
                0.4 * recipe['hsi'] +
                0.4 * (255 - recipe['esi']) +
                0.2 * recipe['ppi']
            ) / 2.55
            
            recommendations.append(recipe)
        
        return recommendations
    
    def calculate_preference_score(self, recipe):
        """
        Recept √©rt√©kel√©se CSOPORTONK√âNT ELT√âR≈ê INFORM√ÅCI√ì alapj√°n
        A/B/C teszt hat√°s√°nak szimul√°l√°sa
        """
        
        # ===== CSOPORTONK√âNTI L√ÅTHAT√ìS√ÅG =====
        if self.group == 'A':
            # A CSOPORT: NEM l√°tja a pontsz√°mokat
            score = self._calculate_intuitive_score(recipe)
            
        elif self.group == 'B':
            # B CSOPORT: L√ÅTJA a HSI/ESI/PPI pontsz√°mokat
            hsi = recipe.get('hsi', 50)
            esi = recipe.get('esi', 50) 
            ppi = recipe.get('ppi', 50)
            score = self._calculate_informed_score(recipe, hsi, esi, ppi)
            
        elif self.group == 'C':
            # C CSOPORT: L√ÅTJA a pontsz√°mokat + MAGYAR√ÅZATOT
            hsi = recipe.get('hsi', 50)
            esi = recipe.get('esi', 50)
            ppi = recipe.get('ppi', 50) 
            score = self._calculate_explained_score(recipe, hsi, esi, ppi)
        
        else:
            # Fallback
            score = 50.0
        
        # Zaj hozz√°ad√°sa (emberi unpredictability)
        noise = random.uniform(-5, 5)
        score += noise
        
        return max(0, min(100, score))
    
    def _calculate_intuitive_score(self, recipe):
        """
        A CSOPORT: Intuit√≠v d√∂nt√©s pontsz√°mok n√©lk√ºl
        Csak c√≠m, kateg√≥ria, √∂sszetev≈ëk alapj√°n
        """
        score = 50.0  # Alappontsz√°m
        
        title = recipe.get('title', '').lower()
        category = recipe.get('category', '').lower()
        ingredients = recipe.get('ingredients', '').lower()
        
        # ===== INTUIT√çV PREFERENCI√ÅK =====
        
        # Eg√©szs√©gtudatos felhaszn√°l√≥k
        if self.user_type == 'egeszsegtudatos':
            healthy_keywords = ['sal√°ta', 'z√∂lds√©g', 'quinoa', 'avok√°d√≥', 'brokkoli', 
                               'spen√≥t', 'nat√∫r', 'bio', 'teljes ki≈ërl√©s≈±']
            for keyword in healthy_keywords:
                if keyword in title or keyword in ingredients:
                    score += 15
            
            unhealthy_keywords = ['s√ºlt', 'r√°ntott', 'szalonna', 'kolb√°sz', 'zs√≠ros']
            for keyword in unhealthy_keywords:
                if keyword in title or keyword in ingredients:
                    score -= 10
        
        # K√∂rnyezettudatos felhaszn√°l√≥k  
        elif self.user_type == 'kornyezettudatos':
            eco_keywords = ['veget√°ri√°nus', 'veg√°n', 'n√∂v√©nyi', 'z√∂lds√©g', 'bab', 
                           'lencse', 'csicseribors√≥', 'tofu', 'helyi']
            for keyword in eco_keywords:
                if keyword in title or keyword in ingredients:
                    score += 12
            
            meat_keywords = ['marhah√∫s', 'sert√©s', 'csirke', 'hal', 'tonhal']
            for keyword in meat_keywords:
                if keyword in title or keyword in ingredients:
                    score -= 15
        
        # √çnyencek
        elif self.user_type == 'izorgia':
            tasty_keywords = ['sajtos', 'tejsz√≠nes', 'csokol√°d√©s', 'karamell', 
                             'pizza', 'burger', 'pasta', 'rizott√≥']
            for keyword in tasty_keywords:
                if keyword in title or keyword in ingredients:
                    score += 18
        
        # K√©nyelmi felhaszn√°l√≥k
        elif self.user_type == 'kenyelmi':
            easy_keywords = ['gyors', 'egyszer≈±', 'mikrohull√°m', '15 perc', 
                            'instant', 'melegszendvics']
            for keyword in easy_keywords:
                if keyword in title or keyword in ingredients:
                    score += 20
        
        # √öjdons√°gkeres≈ëk
        elif self.user_type == 'ujdonsagkereso':
            exotic_keywords = ['thai', 'indiai', 'mexik√≥i', 'marokk√≥i', 'kimcsi', 
                              'curry', 'exotic', 'f≈±szeres']
            for keyword in exotic_keywords:
                if keyword in title or keyword in ingredients:
                    score += 16
        
        return score
    
    def _calculate_informed_score(self, recipe, hsi, esi, ppi):
        """
        B CSOPORT: Tudatos d√∂nt√©s pontsz√°mok alapj√°n
        L√°tja a HSI/ESI/PPI √©rt√©keket
        """
        # ESI inverz (alacsonyabb = jobb)
        esi_inv = 255 - esi
        
        # Pontsz√°mok alapj√°n sz√°m√≠tott preferencia
        score = (
            self.preferences['hsi_weight'] * (hsi / 100.0) +
            self.preferences['esi_weight'] * (esi_inv / 255.0) +
            self.preferences['ppi_weight'] * (ppi / 100.0)
        ) * 100
        
        # Er≈ësebb s√∫lyoz√°s a prefer√°lt metrik√°n
        if self.user_type == 'egeszsegtudatos' and hsi > 80:
            score += 10  # B√≥nusz magas HSI-√©rt
        elif self.user_type == 'kornyezettudatos' and esi < 100:  # Alacsony ESI
            score += 10  # B√≥nusz alacsony k√∂rnyezeti hat√°s√©rt
        elif self.user_type == 'izorgia' and ppi > 70:
            score += 10  # B√≥nusz magas n√©pszer≈±s√©g√©rt
        
        return score
    
    def _calculate_explained_score(self, recipe, hsi, esi, ppi):
        """
        C CSOPORT: Magyar√°zattal t√°mogatott tudatos d√∂nt√©s
        L√°tja a pontsz√°mokat + MAGYAR√ÅZATOT
        """
        # Alappontsz√°m mint B csoportn√°l
        score = self._calculate_informed_score(recipe, hsi, esi, ppi)
        
        # Magyar√°zat hat√°s szimul√°l√°sa
        explanation_bonus = 0
        
        if self.user_type == 'egeszsegtudatos':
            if hsi > 85:
                explanation_bonus += 15  # "Ez az √©tel nagyon eg√©szs√©ges!"
            elif hsi < 40:
                explanation_bonus -= 10  # "Ez az √©tel kev√©sb√© eg√©szs√©ges"
        
        elif self.user_type == 'kornyezettudatos':
            if esi < 80:  # Alacsony k√∂rnyezeti hat√°s
                explanation_bonus += 15  # "Ez az √©tel k√∂rnyezetbar√°t!"
            elif esi > 180:
                explanation_bonus -= 10  # "Ez az √©tel nagyobb k√∂rnyezeti hat√°ssal b√≠r"
        
        elif self.user_type == 'izorgia':
            if ppi > 80:
                explanation_bonus += 15  # "Ez az √©tel nagyon n√©pszer≈±!"
            elif ppi < 30:
                explanation_bonus -= 5   # "Ez az √©tel kev√©sb√© n√©pszer≈±"
        
        # Kiegyens√∫lyozott felhaszn√°l√≥k jobban figyelnek minden metrik√°ra
        elif self.user_type == 'kiegyensulyozott':
            composite = (hsi + (255-esi)/2.55 + ppi) / 3
            if composite > 70:
                explanation_bonus += 12  # "Ez az √©tel √∂sszess√©g√©ben kiv√°l√≥!"
            elif composite < 40:
                explanation_bonus -= 8
        
        score += explanation_bonus
        
        # XAI EFFECT: A magyar√°zat n√∂veli a bizalmat
        confidence_boost = 5
        score += confidence_boost
        
        return score
    
    def select_recipe(self, recommendations):
        """
        Recept v√°laszt√°sa CSOPORTONK√âNT ELT√âR≈ê LOGIK√ÅVAL
        """
        if not recommendations:
            return None
        
        logger.info(f"üéØ {self.username} (Csoport {self.group}) v√°laszt {len(recommendations)} aj√°nl√°s k√∂z√ºl...")
        
        # Minden recept pontoz√°sa a csoport l√°that√≥s√°ga szerint
        scored_recipes = []
        for recipe in recommendations:
            score = self.calculate_preference_score(recipe)
            scored_recipes.append((recipe, score))
            
            # Debug info
            if self.group == 'A':
                logger.info(f"   üìã {recipe['title']}: {score:.1f} pont (intuit√≠v)")
            elif self.group == 'B':
                logger.info(f"   üìä {recipe['title']}: {score:.1f} pont (HSI:{recipe.get('hsi', '?')}, ESI:{recipe.get('esi', '?')}, PPI:{recipe.get('ppi', '?')})")
            elif self.group == 'C':
                logger.info(f"   üìà {recipe['title']}: {score:.1f} pont (pontsz√°mok + magyar√°zat)")
        
        # S√∫lyozott v√©letlenszer≈± v√°laszt√°s
        weights = [max(score, 0.1) for _, score in scored_recipes]
        
        # Softmax-szer≈± s√∫lyoz√°s (h≈ëm√©rs√©klet: csoport f√ºgg≈ë)
        if self.group == 'A':
            temperature = 25  # Nagyobb bizonytalans√°g
        elif self.group == 'B':
            temperature = 20  # K√∂zepes bizonytalans√°g
        elif self.group == 'C':
            temperature = 15  # Kisebb bizonytalans√°g
        else:
            temperature = 20
        
        exp_weights = [pow(max(w, 0.1)/temperature, 2) for w in weights]
        total_weight = sum(exp_weights)
        probabilities = [w/total_weight for w in exp_weights]
        
        # V√°laszt√°s
        chosen_index = random.choices(range(len(scored_recipes)), weights=probabilities)[0]
        chosen_recipe, chosen_score = scored_recipes[chosen_index]
        
        logger.info(f"‚úÖ {self.username} (Csoport {self.group}) v√°lasztott: {chosen_recipe['title']} (pontsz√°m: {chosen_score:.1f})")
        
        return chosen_recipe
    
    def submit_choice(self, recipe):
        """V√°laszt√°s elk√ºld√©se round sz√°mmal"""
        try:
            choice_data = {'recipe_id': recipe['id']}
            response = self.session.post(
                f"{self.base_url}/select_recipe",
                json=choice_data,
                headers={'Content-Type': 'application/json'},
                timeout=10
            )
            
            if response.status_code == 200:
                result = response.json()
                if result.get('success'):
                    logger.info(f"‚úÖ {self.username} v√°laszt√°s r√∂gz√≠tve")
                    
                    # K√∂r√∂nk√©nti v√°laszt√°s statisztik√°k
                    choice_record = {
                        'recipe_id': recipe['id'],
                        'recipe_title': recipe['title'],
                        'hsi': recipe.get('hsi', 0),
                        'esi': recipe.get('esi', 0),
                        'ppi': recipe.get('ppi', 0),
                        'composite_score': recipe.get('composite_score', 0),
                        'round_number': recipe.get('round_number', len(self.choices_made) + 1),
                        'recommendation_type': recipe.get('recommendation_type', 'unknown'),
                        'user_score': self.calculate_preference_score(recipe),
                        'timestamp': datetime.now(),
                        'user_type': self.user_type,
                        'group': self.group
                    }
                    self.choices_made.append(choice_record)
                    self.total_choices += 1
                    
                    return True
            
            logger.warning(f"‚ùå {self.username} v√°laszt√°s r√∂gz√≠t√©s sikertelen")
            return False
            
        except Exception as e:
            logger.error(f"‚ùå {self.username} v√°laszt√°s r√∂gz√≠t√©s hiba: {e}")
            return False
    
    def simulate_session(self):
        """Teljes k√∂r√∂nk√©nti szimul√°ci√≥s session"""
        logger.info(f"\nüé≠ {self.username} ({self.user_type}) k√∂r√∂nk√©nti szimul√°ci√≥ja...")
        self.session_start_time = datetime.now()
        
        # 1. Regisztr√°ci√≥ √©s bejelentkez√©s
        if not self.register():
            return False, self.get_session_summary()
        
        time.sleep(random.uniform(1, 3))
        
        if not self.login():
            return False, self.get_session_summary()
        
        time.sleep(random.uniform(2, 5))
        
        # ===== K√ñR√ñNK√âNTI V√ÅLASZT√ÅSOK =====
        choices_to_make = random.randint(*self.preferences['choices_per_session'])
        successful_choices = 0
        
        for round_num in range(1, choices_to_make + 1):
            logger.info(f"üîÑ {self.username} - {round_num}. k√∂r kezd√©se")
            
            # V√°laszt√°si val√≥sz√≠n≈±s√©g
            if random.random() > self.preferences['choice_probability']:
                logger.info(f"‚è≠Ô∏è {self.username} kihagyja a {round_num}. k√∂rt")
                continue
            
            # Aj√°nl√°sok k√©r√©se (VAL√ìS API)
            recommendations = self.get_recommendations()
            if not recommendations:
                logger.warning(f"‚ùå {self.username} - Nincs aj√°nl√°s a {round_num}. k√∂rben")
                continue
            
            # "Gondolkod√°si" id≈ë
            thinking_time = random.uniform(3, 8)
            logger.info(f"ü§î {self.username} gondolkodik {thinking_time:.1f} m√°sodpercig...")
            time.sleep(thinking_time)
            
            # Recept v√°laszt√°sa
            chosen_recipe = self.select_recipe(recommendations)
            if not chosen_recipe:
                continue
            
            time.sleep(random.uniform(1, 3))
            
            # V√°laszt√°s r√∂gz√≠t√©se
            if self.submit_choice(chosen_recipe):
                successful_choices += 1
                logger.info(f"‚úÖ {self.username} - {round_num}. k√∂r: {chosen_recipe['title']} kiv√°lasztva")
            else:
                logger.warning(f"‚ùå {self.username} - {round_num}. k√∂r r√∂gz√≠t√©s sikertelen")
            
            # V√°rakoz√°s k√∂vetkez≈ë k√∂rig
            inter_round_delay = random.uniform(2, 6)
            logger.info(f"‚è±Ô∏è {self.username} v√°r {inter_round_delay:.1f} m√°sodpercet...")
            time.sleep(inter_round_delay)
        
        success = successful_choices > 0
        session_summary = self.get_session_summary()
        
        logger.info(f"üéâ {self.username} szimul√°ci√≥ja befejezve - Csoport: {self.group}, "
                   f"K√∂r√∂k: {successful_choices}/{choices_to_make}")
        
        return success, session_summary
    
    def get_session_summary(self):
        """Session √∂sszefoglal√≥"""
        session_duration = (datetime.now() - self.session_start_time).total_seconds() if self.session_start_time else 0
        
        avg_composite_score = 0
        if self.choices_made:
            avg_composite_score = np.mean([choice['composite_score'] for choice in self.choices_made])
        
        return {
            'username': self.username,
            'user_type': self.user_type,
            'group': self.group,
            'total_choices': self.total_choices,
            'avg_composite_score': avg_composite_score,
            'session_duration': session_duration,
            'choices': self.choices_made.copy()
        }

# ===== P√ÅRHUZAMOS FELDOLGOZ√ÅS =====
def simulate_user_wrapper(user_data):
    """Wrapper f√ºggv√©ny a p√°rhuzamos feldolgoz√°shoz"""
    user_type, username = user_data
    user = VirtualUser(user_type, username)
    success, summary = user.simulate_session()
    return success, summary

def create_virtual_users(count=200):
    """Virtu√°lis felhaszn√°l√≥k l√©trehoz√°sa"""
    user_types = [
        'egeszsegtudatos',
        'kornyezettudatos', 
        'izorgia',
        'kiegyensulyozott',
        'kenyelmi',
        'ujdonsagkereso'
    ]
    
    users = []
    for i in range(count):
        user_type = random.choice(user_types)
        username = f"virtual_{user_type}_{i+1:03d}"
        users.append((user_type, username))
    
    return users

def run_enhanced_simulation(user_count=100, max_workers=4, use_parallel=True):
    """A/B/C csoportonk√©nti szimul√°ci√≥ futtat√°sa"""
    logger.info(f"üöÄ A/B/C CSOPORTONK√âNTI Virtu√°lis felhaszn√°l√≥k szimul√°ci√≥ja")
    logger.info(f"üë• {user_count} felhaszn√°l√≥, {'p√°rhuzamos' if use_parallel else 'soros'} feldolgoz√°s")
    
    users = create_virtual_users(user_count)
    
    results = {
        'successful': 0,
        'failed': 0,
        'by_type': {},
        'by_group': {'A': 0, 'B': 0, 'C': 0},
        'session_summaries': [],
        'total_choices': 0,
        'avg_composite_scores': {'A': [], 'B': [], 'C': []},
        'group_choice_details': {'A': [], 'B': [], 'C': []}
    }
    
    start_time = datetime.now()
    
    if use_parallel:
        # P√°rhuzamos feldolgoz√°s
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            future_to_user = {
                executor.submit(simulate_user_wrapper, user_data): user_data 
                for user_data in users
            }
            
            completed = 0
            for future in future_to_user:
                try:
                    success, summary = future.result(timeout=120)  # 2 perc timeout
                    
                    if success:
                        results['successful'] += 1
                        results['by_group'][summary['group']] += 1
                        results['total_choices'] += summary['total_choices']
                        
                        if summary['avg_composite_score'] > 0:
                            results['avg_composite_scores'][summary['group']].append(summary['avg_composite_score'])
                        
                        # R√©szletes v√°laszt√°sok t√°rol√°sa csoportonk√©nt
                        for choice in summary['choices']:
                            results['group_choice_details'][summary['group']].append(choice)
                        
                        # T√≠pus szerint statisztika
                        if summary['user_type'] not in results['by_type']:
                            results['by_type'][summary['user_type']] = 0
                        results['by_type'][summary['user_type']] += 1
                    else:
                        results['failed'] += 1
                    
                    results['session_summaries'].append(summary)
                    completed += 1
                    
                    if completed % 20 == 0:
                        logger.info(f"üìà Progress: {completed}/{user_count} felhaszn√°l√≥ k√©sz")
                        
                except Exception as e:
                    logger.error(f"‚ùå Felhaszn√°l√≥ szimul√°ci√≥ hiba: {e}")
                    results['failed'] += 1
    else:
        # Soros feldolgoz√°s
        for i, (user_type, username) in enumerate(users):
            try:
                user = VirtualUser(user_type, username)
                success, summary = user.simulate_session()
                
                if success:
                    results['successful'] += 1
                    results['by_group'][summary['group']] += 1
                    results['total_choices'] += summary['total_choices']
                    
                    if summary['avg_composite_score'] > 0:
                        results['avg_composite_scores'][summary['group']].append(summary['avg_composite_score'])
                    
                    for choice in summary['choices']:
                        results['group_choice_details'][summary['group']].append(choice)
                    
                    if summary['user_type'] not in results['by_type']:
                        results['by_type'][summary['user_type']] = 0
                    results['by_type'][summary['user_type']] += 1
                else:
                    results['failed'] += 1
                
                results['session_summaries'].append(summary)
                
                if (i + 1) % 15 == 0:
                    logger.info(f"üìà Progress: {i+1}/{user_count} felhaszn√°l√≥ k√©sz")
                
                # R√∂vid sz√ºnet a szerver k√≠m√©l√©se √©rdek√©ben
                time.sleep(random.uniform(0.5, 1.5))
                
            except Exception as e:
                logger.error(f"‚ùå {username} szimul√°ci√≥s hiba: {e}")
                results['failed'] += 1
    
    # ===== A/B/C CSOPORTONK√âNTI EREDM√âNYEK ELEMZ√âSE =====
    duration = datetime.now() - start_time
    
    logger.info(f"\nüìä === A/B/C CSOPORTONK√âNTI SZIMUL√ÅCI√ì EREDM√âNYEI ===")
    logger.info(f"‚è±Ô∏è  Fut√°si id≈ë: {duration}")
    logger.info(f"‚úÖ Sikeres: {results['successful']}")
    logger.info(f"‚ùå Sikertelen: {results['failed']}")
    logger.info(f"üìà Sikeress√©gi ar√°ny: {results['successful']/(results['successful']+results['failed'])*100:.1f}%")
    logger.info(f"üéØ √ñsszes v√°laszt√°s: {results['total_choices']}")
    
    logger.info(f"\nüë• Csoportonk√©nti eloszl√°s √©s √°tlagos kompozit pontsz√°mok:")
    group_stats = {}
    for group in ['A', 'B', 'C']:
        count = results['by_group'][group]
        if results['avg_composite_scores'][group]:
            avg_composite = np.mean(results['avg_composite_scores'][group])
            std_composite = np.std(results['avg_composite_scores'][group])
            group_stats[group] = avg_composite
            logger.info(f"  {group} csoport: {count} felhaszn√°l√≥, √°tlag kompozit: {avg_composite:.1f} (¬±{std_composite:.1f})")
        else:
            logger.info(f"  {group} csoport: {count} felhaszn√°l√≥, nincs v√°laszt√°s")
    
    logger.info(f"\nüé≠ Felhaszn√°l√≥ t√≠pusok eloszl√°sa:")
    for user_type, count in results['by_type'].items():
        logger.info(f"  {user_type}: {count} felhaszn√°l√≥")
    
    # ===== A/B/C HIPOT√âZIS ELLEN≈êRZ√âS =====
    logger.info(f"\nüî¨ A/B/C HIPOT√âZIS ELLEN≈êRZ√âS:")
    logger.info(f"V√°rt sorrend: C > B > A (magyar√°zat + pontsz√°mok > csak pontsz√°mok > kontroll)")
    
    if len(group_stats) >= 2:
        sorted_groups = sorted(group_stats.items(), key=lambda x: x[1], reverse=True)
        ranking_str = ' > '.join([f'{g}({v:.1f})' for g, v in sorted_groups])
        logger.info(f"  üìä T√©nyleges rangsor: {ranking_str}")
        
        # Hipot√©zis valid√°ci√≥
        if len(sorted_groups) >= 3:
            if sorted_groups[0][0] == 'C' and sorted_groups[1][0] == 'B' and sorted_groups[2][0] == 'A':
                logger.info(f"  ‚úÖ HIPOT√âZIS TELJES M√âRT√âKBEN IGAZOL√ìDOTT: C > B > A")
                hypothesis_result = "FULLY_CONFIRMED"
            elif sorted_groups[0][0] == 'C':
                logger.info(f"  ‚úÖ HIPOT√âZIS R√âSZBEN IGAZOL√ìDOTT: C csoport a legjobb")
                hypothesis_result = "PARTIALLY_CONFIRMED"
            else:
                logger.info(f"  ‚ùå HIPOT√âZIS NEM IGAZOL√ìDOTT")
                hypothesis_result = "NOT_CONFIRMED"
        elif len(sorted_groups) == 2:
            if 'C' in group_stats and 'B' in group_stats and group_stats['C'] > group_stats['B']:
                logger.info(f"  ‚úÖ HIPOT√âZIS R√âSZBEN IGAZOL√ìDOTT: C > B")
                hypothesis_result = "PARTIALLY_CONFIRMED"
            elif 'C' in group_stats and 'A' in group_stats and group_stats['C'] > group_stats['A']:
                logger.info(f"  ‚úÖ HIPOT√âZIS R√âSZBEN IGAZOL√ìDOTT: C > A")
                hypothesis_result = "PARTIALLY_CONFIRMED"
            else:
                logger.info(f"  ‚ùì HIPOT√âZIS BIZONYTALAN")
                hypothesis_result = "UNCERTAIN"
        else:
            hypothesis_result = "INSUFFICIENT_DATA"
    else:
        logger.info(f"  ‚ùì Nincs elegend≈ë adat a hipot√©zis ellen≈ërz√©s√©hez")
        hypothesis_result = "INSUFFICIENT_DATA"
    
    # ===== R√âSZLETES CSOPORTONK√âNTI STATISZTIK√ÅK =====
    logger.info(f"\nüìà R√âSZLETES CSOPORTONK√âNTI ELEMZ√âS:")
    
    for group in ['A', 'B', 'C']:
        choices = results['group_choice_details'][group]
        if choices:
            hsi_scores = [choice['hsi'] for choice in choices if choice['hsi'] > 0]
            esi_scores = [choice['esi'] for choice in choices if choice['esi'] > 0]
            ppi_scores = [choice['ppi'] for choice in choices if choice['ppi'] > 0]
            
            logger.info(f"\n  üìä {group} csoport r√©szletes statisztik√°k:")
            logger.info(f"    V√°laszt√°sok sz√°ma: {len(choices)}")
            
            if hsi_scores:
                logger.info(f"    √Åtlag HSI: {np.mean(hsi_scores):.1f}")
            if esi_scores:
                logger.info(f"    √Åtlag ESI: {np.mean(esi_scores):.1f}")
            if ppi_scores:
                logger.info(f"    √Åtlag PPI: {np.mean(ppi_scores):.1f}")
            
            # Preferencia t√≠pusok eloszl√°sa csoportonk√©nt
            user_types_in_group = [choice['user_type'] for choice in choices]
            from collections import Counter
            type_counts = Counter(user_types_in_group)
            logger.info(f"    Felhaszn√°l√≥ t√≠pusok: {dict(type_counts)}")
    
    # ===== TUDOM√ÅNYOS METRIK√ÅK SZ√ÅM√çT√ÅSA =====
    logger.info(f"\nüî¨ TUDOM√ÅNYOS METRIK√ÅK:")
    
    # Effect size sz√°m√≠t√°s (Cohen's d)
    if 'A' in group_stats and 'C' in group_stats:
        a_scores = results['avg_composite_scores']['A']
        c_scores = results['avg_composite_scores']['C']
        
        if len(a_scores) > 1 and len(c_scores) > 1:
            pooled_std = np.sqrt(((len(a_scores)-1)*np.var(a_scores) + (len(c_scores)-1)*np.var(c_scores)) / (len(a_scores)+len(c_scores)-2))
            cohens_d = (np.mean(c_scores) - np.mean(a_scores)) / pooled_std
            logger.info(f"  üìè Cohen's d (C vs A): {cohens_d:.3f}")
            
            if abs(cohens_d) < 0.2:
                effect_size = "kicsi"
            elif abs(cohens_d) < 0.5:
                effect_size = "k√∂zepes"
            else:
                effect_size = "nagy"
            logger.info(f"  üìä Hat√°sm√©ret: {effect_size}")
    
    # Statisztikai szignifikancia becsl√©s
    logger.info(f"  üìã Minta nagys√°gok:")
    for group in ['A', 'B', 'C']:
        if results['avg_composite_scores'][group]:
            logger.info(f"    {group} csoport: n={len(results['avg_composite_scores'][group])}")
    
    results['hypothesis_result'] = hypothesis_result
    results['group_statistics'] = group_stats
    
    return results

def export_enhanced_results(results, filename=None):
    """A/B/C csoportonk√©nti eredm√©nyek export√°l√°sa"""
    if not filename:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"abc_greenrec_simulation_{timestamp}.csv"
    
    # R√©szletes adatok export√°l√°sa
    export_rows = []
    for summary in results['session_summaries']:
        base_row = {
            'username': summary['username'],
            'user_type': summary['user_type'],
            'group': summary['group'],
            'total_choices': summary['total_choices'],
            'avg_composite_score': summary['avg_composite_score'],
            'session_duration': summary['session_duration'],
            'hypothesis_result': results.get('hypothesis_result', 'UNKNOWN')
        }
        
        if summary['choices']:
            for i, choice in enumerate(summary['choices']):
                row = base_row.copy()
                row.update({
                    'choice_number': i + 1,
                    'recipe_id': choice['recipe_id'],
                    'recipe_title': choice['recipe_title'],
                    'hsi': choice['hsi'],
                    'esi': choice['esi'], 
                    'ppi': choice['ppi'],
                    'composite_score': choice['composite_score'],
                    'user_preference_score': choice['user_score'],
                    'round_number': choice.get('round_number', i + 1),
                    'recommendation_type': choice.get('recommendation_type', 'unknown'),
                    'choice_timestamp': choice['timestamp']
                })
                export_rows.append(row)
        else:
            export_rows.append(base_row)
    
    df = pd.DataFrame(export_rows)
    df.to_csv(filename, index=False, encoding='utf-8')
    logger.info(f"üìÅ A/B/C csoportonk√©nti eredm√©nyek export√°lva: {filename}")
    
    # √ñsszes√≠t≈ë statisztik√°k k√ºl√∂n f√°jlba
    summary_filename = filename.replace('.csv', '_summary.csv')
    summary_data = []
    
    for group in ['A', 'B', 'C']:
        if results['avg_composite_scores'][group]:
            summary_data.append({
                'group': group,
                'user_count': results['by_group'][group],
                'total_choices': len(results['group_choice_details'][group]),
                'avg_composite_score': np.mean(results['avg_composite_scores'][group]),
                'std_composite_score': np.std(results['avg_composite_scores'][group]),
                'hypothesis_result': results.get('hypothesis_result', 'UNKNOWN')
            })
    
    summary_df = pd.DataFrame(summary_data)
    summary_df.to_csv(summary_filename, index=False)
    logger.info(f"üìä √ñsszes√≠t≈ë statisztik√°k: {summary_filename}")
    
    return filename, summary_filename

if __name__ == "__main__":
    # ===== A/B/C CSOPORTONK√âNTI SZIMUL√ÅCI√ì KONFIGUR√ÅCI√ìJA =====
    
    logger.info("üöÄ A/B/C CSOPORTONK√âNTI GREENREC SZIMUL√ÅCI√ì IND√çT√ÅSA")
    logger.info("üìã Hipot√©zis: C (pontsz√°mok + magyar√°zat) > B (csak pontsz√°mok) > A (kontroll)")
    
    # KONFIGUR√ÅCI√ìS OPCI√ìK:
    
    # Kis teszt (fejleszt√©shez):
    # results = run_enhanced_simulation(user_count=30, max_workers=3, use_parallel=True)
    
    # K√∂zepes teszt (aj√°nlott):
    results = run_enhanced_simulation(user_count=75, max_workers=4, use_parallel=True)
    
    # Nagy l√©pt√©k≈± teszt (ha gyors a Heroku):
    # results = run_enhanced_simulation(user_count=150, max_workers=6, use_parallel=True)
    
    # Eredm√©nyek export√°l√°sa
    csv_file, summary_file = export_enhanced_results(results)
    
    logger.info(f"\nüéâ A/B/C CSOPORTONK√âNTI SZIMUL√ÅCI√ì BEFEJEZVE!")
    logger.info(f"üìÑ R√©szletes eredm√©nyek: {csv_file}")
    logger.info(f"üìä √ñsszes√≠t≈ë statisztik√°k: {summary_file}")
    
    # V√©gs≈ë hipot√©zis √©rt√©kel√©s
    hypothesis_result = results.get('hypothesis_result', 'UNKNOWN')
    if hypothesis_result == 'FULLY_CONFIRMED':
        logger.info(f"üèÜ KIV√ÅL√ì! A hipot√©zis teljes m√©rt√©kben igazol√≥dott!")
        logger.info(f"üéØ A magyar√°zatok √©s pontsz√°mok l√°that√≥s√°ga jelent≈ësen befoly√°solja a d√∂nt√©seket!")
    elif hypothesis_result == 'PARTIALLY_CONFIRMED':
        logger.info(f"‚úÖ J√ì! A hipot√©zis r√©szben igazol√≥dott!")
        logger.info(f"üéØ A pontsz√°mok/magyar√°zatok hat√°sa kimutathat√≥!")
    else:
        logger.info(f"üìä Az eredm√©nyek tov√°bbi elemz√©st ig√©nyelnek")
    
    logger.info(f"üî¨ K√∂vetkez≈ë l√©p√©s: T√∂ltsd fel a CSV f√°jlokat statisztikai elemz√©sre!")
    logger.info(f"üìà Aj√°nlott eszk√∂z√∂k: Python pandas, R, SPSS, vagy Excel pivot t√°bl√°k")
